---
title: "应用程序与操作系统协作"
date: 2023-05-07T16:41:28+08:00
draft: false
summary: "应用程序和操作系统都是软件， CPU会将它们一视同仁，甚至CPU不知道自己在执行的程序是操作系统还是一般应用软件。 CPU只知道去cs:ip寄存器中指向的内存取出指令并执行 ，它不知道什么是操作系统。 编程语言其实只是编译器和大家的约定，只要写入这样的代码，编译器便将其翻译成某种机器指令，翻译成什么样取决于编译器的行为"
tags: [Linux]
categories: [OS]
source: csdn
source_id: "130544607"
---

应用程序和操作系统都是软件， CPU会将它们一视同仁，甚至CPU不知道自己在执行的程序是操作系统还是一般应用软件。**CPU只知道去cs:ip寄存器中指向的内存取出指令并执行** ，它不知道什么是操作系统。

编程语言其实只是编译器和大家的约定，只要写入这样的代码，编译器便将其翻译成某种机器指令，翻译成什么样取决于编译器的行为。**编译器还提供了一套库函数 ，库函数中又有封装的系统调用，这样的代码集合称之为运行库**。C语言的运行库成为C运行库，就是所谓的CRT。应用程序加上操作系统提供的功能才算是完整的程序，平时写的应用程序只能算是半成品，还需要调用操作系统提供的函数才能完整地做出一件事，而这些函数就是系统调用。

**用户态和内核态是对CPU来讲的** 而不是用户进程，是指CPU运行在用户态（特权3级）还是内核态（特权0级）。**用户进程陷入内核态是指由于内部或外部中断发生 ，当前进程被暂时终止执行，其上下文被内核的中断程序保存起来后，开始执行一段内核的代码**。是内核的代码而不是用户及程序在内核的代码，用户代码不可能在内核中存在，所以“用户态和内核态”是相对于CPU而言的。当应用程序陷入内核之后，自己已经下CPU了，以后发生的事情应用程序完全不知道，此时它的上下文环境已经被保存到了自己在内核态的的栈中了，CPU上运行的程序已经是内核程序。

也就是说应用程序其实是通过系统调用和操作系统配合来完成某项功能的。可能有人会说自己写应用程序时从来没写过系统调用的代码，这是因为用到的标准库帮我们完成了这些事。库中提供的函数其实都已经封装好了系统调用，需要下载源码才会看到。

> 其实也可以跨过标准库直接执行系统调用，**对于Linux系统来说 ，直接嵌入汇编代码"int 0x80"便可以直接执行系统调用，当然要提前设置好系统调用的子功能号，该子功能号用寄存器eax存储。**
> 
> 各个操作系统都有自己的系统调用号，所以我们在下载编译器时需要选择正确的系统版本，编译器厂商在代码中已经把宿主系统的系统调用号写死了。
