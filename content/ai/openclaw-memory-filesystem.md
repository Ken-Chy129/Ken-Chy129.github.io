---
title: "用“文件系统式记忆”实现按需加载与共享记忆"
date: 2026-02-24
draft: false
summary: "多 Agent 的真实痛点不是‘变笨’，而是记忆组织方式不对：把记忆当文件系统来管理，先索引再摘要再全文，并用生命周期标签控制膨胀，让 Agent 之间真正共享上下文。"
tags: ["OpenClaw", "Agent", "Memory", "OpenViking"]
categories: ["AI 工程"]
---

> 多 Agent 很爽，直到你发现：它们活得像一群陌生人。

这篇文章把我在使用 **OpenClaw**（以及类似的多 Agent 框架）时遇到的“记忆问题”拆开讲清楚，并给出一套可以快速落地的改造思路：

- **L0/L1/L2 三层按需加载**：先读索引，再读摘要，最后才读全文
- **P0/P1/P2 生命周期标签**：给记忆加“保质期”，控制膨胀
- **shared-memory 共享层**：解决 Agent 之间的信息孤岛

思路受 **OpenViking**（字节跳动开源项目）启发：

> 把 Agent 的记忆当“文件系统”来管理，而不是当“文档”从头读到尾。

---

## 1. 真实痛点：为什么多 Agent 会“失忆”且“烧钱”

如果你跑过多个 Agent，大概率见过这些场景：

1) **每次开新对话都要重新自我介绍**
- 你刚说完“写作风格/目标读者/偏好”，下次它又问一遍。

2) **Agent A 做完的事，Agent B 完全不知道**
- 技术 Agent 修好了一个配置问题；你让写作 Agent 写复盘，它却要你从头复述。

3) **聊了半小时的上下文，一刷新全没了**
- 你不得不把背景信息再喂一遍。

这些问题的根源通常只有一句话：

**Agent 之间没有共享记忆，且每次“全量读记忆”会导致 token 线性燃烧。**

于是出现两个副作用：
- **重复交代 = 重复花钱**（token 成本）
- **信息孤岛 = 协作效率低**（多 Agent 变成多段单聊）

---

## 2. 核心理念：把记忆当“文件系统”，而不是当“文档”

想象你打开电脑找资料：

- 你不会把硬盘里所有文件全文读一遍
- 你会先看“目录/文件夹名”（索引）
- 再打开目标文件

对 Agent 记忆也应如此。

---

## 3. L0/L1/L2：三层按需加载（Layered Memory Loading）

把记忆分为三层：

- **L0：目录索引（Index）**
  - 只回答：记忆里有哪些“主题/文件/类别”
- **L1：内容摘要（Summary）**
  - 只回答：某个主题/文件讲了什么（可控的几百 tokens）
- **L2：完整内容（Full Text）**
  - 只有确认需要时才加载全文（几千 tokens 甚至更多）

一个常见的 token 量级（仅作直觉参考）：

- L0：~100 tokens
- L1：~500 tokens
- L2：~5000+ tokens

### 3.1 读取策略（从“每次全读”→“按需读取”）

- Agent 启动时只读 **L0**：先知道“都有什么”
- 需要某类信息时读 **L1**：确认是否命中
- 确认需要再读 **L2**：加载全文

这能把大量“无效全量加载”的 token 消耗砍掉。

---

## 4. P0/P1/P2：给记忆加“保质期”（Lifecycle / TTL）

光分层不够，记忆会随着时间膨胀。解决办法是引入生命周期标签：

- **P0：核心信息（永久）**
  - 例如：你的称呼、写作风格、关键系统配置
- **P1：活跃项目（保留 90 天，之后归档）**
  - 例如：当前正在推进的项目、正在调试的功能
- **P2：临时信息（保留 30 天，之后清理/归档）**
  - 例如：某次对话的细节、临时 debug 记录

配合一个每天跑一次的脚本：
- P1 超过 90 天 → 自动归档
- P2 超过 30 天 → 自动清理/归档

记忆不会无限膨胀，但需要时仍能从归档中找回来。

---

## 5. shared-memory：建立共享记忆层，打破“信息孤岛”

多 Agent 协作最大的问题是：**你告诉 A 的偏好，B 不知道；你和 C 确认的方案，D 没听说过。**

建议建立一个所有 Agent 都能读取的共享目录：

```text
shared-memory/
├── .abstract              # 共享记忆索引（L0）
├── user-profile.md        # 用户画像（所有 Agent 共用）
├── active-tasks.md        # 当前进行中的任务
└── cross-agent-log.md     # 跨 Agent 协作结论日志
```

### 5.1 不写代码也能“自动写共享记忆”

一个实用的规则是：

> 完成重要任务后，把关键结论追加到 `shared-memory/cross-agent-log.md`。

格式建议：

```md
- [2026-02-24] [Tech Agent] 修复了 X 问题：根因是 Y，解决方案是 Z。
- [2026-02-24] [Writer Agent] 文章结构定稿：A/B/C 三段，读者画像为 D。
```

只记结论，不记过程；每条不超过两行。

在 OpenClaw 的工作流里，可以把这条规则写进 `AGENTS.md`（相当于工作手册），让所有 Agent 在完成任务时遵守。

---

## 6. 30 分钟落地路线图（三步走）

### 第一步：给每个 Agent 加 `.abstract` 索引（10 分钟）

在每个 Agent 的 `memory/` 目录下创建一个 `.abstract` 文件（就是 L0）：

```md
# memory/.abstract
- 用户偏好：写作风格、发布节奏、目标读者
- 系统配置：Agent 列表、通信方式、模型设置
- 项目记录：当前创作任务、历史发布文章
- 工具笔记：常用命令、API 配置、踩坑记录
```

### 第二步：给记忆条目打 P 标签（10 分钟）

在记忆文件条目前加标签：

```md
## [P0] 用户基本信息
- 称呼：xxx
- 写作风格：大白话、第一人称、短句

## [P1] 当前项目：xxx
- 状态：进行中
- 截止：2026-03-01

## [P2] 2026-02-21 临时对话记录
- 讨论了文章大纲
- 确定了标题方案
```

再配一个简单清理脚本（每天扫一次）。

### 第三步：建立共享记忆层（10 分钟）

按上一节创建 `shared-memory/`，并将“共享记忆规则”写进工作手册。

---

## 7. 可复用 Prompt：让 Agent 生成配置与脚本

你可以把下面 Prompt 交给 OpenClaw（或你自己的 Agent Runner），让它直接生成所需文件与脚本：

```text
请根据“文件系统式记忆管理”的方案，给我的 OpenClaw 多 Agent 系统接入分层记忆管理：
1. 为每个 Agent 的 memory 目录添加 .abstract 索引文件（L0）
2. 实现 L0/L1/L2 三层记忆架构（按需加载）
3. 引入 P0/P1/P2 生命周期标签系统（TTL/归档/清理）
4. 创建跨 Agent 的共享记忆层 shared-memory/（包含 .abstract、user-profile、active-tasks、cross-agent-log）
请直接生成所需的配置文件和脚本。
```

---

## 8. 最后一句话（真正的结论）

多 Agent 的记忆问题，核心就两件事：

1) **分层加载**：不要每次全读，先看目录再按需取
2) **共享记忆**：让 Agent 之间能互相通气

当记忆变成“文件系统”，你就能既省 token，又提升协作效率。
